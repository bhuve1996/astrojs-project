---
import BaseLayout from '../layouts/BaseLayout.astro';
import {
  getAllPages,
  getPageTitle,
  getPageDescription,
  getPageOgImage,
  getPageCanonical,
} from '../utils/loadWebsiteData';
import { processPageHtml } from '../utils/processHtml';
import { isExcludedPath, siteConfig } from '../config/site.config';

// Only prerender paths that are actual pages
export const prerender = true;

export async function getStaticPaths() {
  const allPages = getAllPages();

  // Only generate paths for actual pages, not static assets
  const pagePaths = allPages
    .map(page => {
      // Convert URL to slug path string (remove protocol, query strings, trailing slashes)
      // e.g., "https://windscribe.com/download?cpid=features" -> "windscribe.com/download"
      let pagePath = page.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
      // Remove query strings
      pagePath = pagePath.split('?')[0].split('#')[0];

      return pagePath || 'windscribe.com';
    })
    .filter(pagePath => {
      // Exclude paths using config-driven rules
      // This prevents the catch-all route from matching these paths
      return !isExcludedPath(`/${pagePath}`);
    });

  return pagePaths.map(pagePath => {
    // For catch-all routes, slug must be a string, not an array
    // Astro will automatically split it when accessed via Astro.params.slug
    return {
      params: {
        slug: pagePath,
      },
    };
  });
}

const { slug } = Astro.params;
// slug comes as an array for catch-all routes, join it back to a string
const path = slug ? (Array.isArray(slug) ? slug.join('/') : slug) : '';

// Early return for static assets and internal paths (using config)
// These should be handled by middleware, but double-check here as well
// This prevents any processing and route matching warnings
if (!path || isExcludedPath(`/${path}`)) {
  // Return 404 immediately - these paths shouldn't be handled by this route
  return new Response('Not Found', { status: 404, statusText: 'Not Found' });
}

// Find the page by matching the URL
const allPages = getAllPages();

// Normalize path - remove leading slash if present, ensure it matches routing format
let normalizedPath = path.startsWith('/') ? path.slice(1) : path;

let page = allPages.find(p => {
  const pagePath = p.url
    .replace(/^https?:\/\//, '')
    .replace(/\/$/, '')
    .split('?')[0]
    .split('#')[0];

  // Exact match
  if (pagePath === normalizedPath) return true;

  // Match without domain prefix (e.g., "download" matches "windscribe.com/download")
  const pathWithoutDomain = normalizedPath.replace(/^windscribe\.com\/?/, '');
  const pagePathWithoutDomain = pagePath.replace(/^windscribe\.com\/?/, '');

  // Direct match without domain
  if (pathWithoutDomain && pagePathWithoutDomain === pathWithoutDomain) return true;

  // Match if page path ends with the requested path
  if (pathWithoutDomain && pagePath.endsWith(`/${pathWithoutDomain}`)) return true;

  // Match if requested path ends with page path
  if (pagePathWithoutDomain && normalizedPath.endsWith(`/${pagePathWithoutDomain}`)) return true;

  // Match if both are just the segment (e.g., "download" matches "windscribe.com/download")
  if (pathWithoutDomain && pagePath === `windscribe.com/${pathWithoutDomain}`) return true;

  // Path includes page path (e.g., "windscribe.com/download" matches "windscribe.com/download?cpid=features")
  if (pagePath.includes(normalizedPath) || normalizedPath.includes(pagePath)) return true;

  // Handle root domain
  if (
    (normalizedPath === 'windscribe.com' || normalizedPath === '') &&
    (pagePath === 'windscribe.com' || pagePath === siteConfig.baseDomain)
  )
    return true;
  return false;
});

// If not found, try more flexible matching
if (!page) {
  // Try matching by last segment
  const pathSegments = path.split('/');
  const lastSegment = pathSegments[pathSegments.length - 1];

  page = allPages.find(p => {
    const pagePath = p.url
      .replace(/^https?:\/\//, '')
      .replace(/\/$/, '')
      .split('?')[0]
      .split('#')[0];
    const pageSegments = pagePath.split('/');
    const pageLastSegment = pageSegments[pageSegments.length - 1];

    // Match by last segment
    if (lastSegment && pageLastSegment === lastSegment) return true;
    // Match if path is substring of page path
    if (pagePath.includes(path)) return true;
    return false;
  });
}

// Fallback to first page if still not found (guaranteed to exist since we have pages)
if (!page && allPages.length > 0) {
  page = allPages[0];
}

// Ensure we have a page (TypeScript safety)
if (!page) {
  return Astro.redirect('/');
}

const title = getPageTitle(page);
const description = getPageDescription(page);
const ogImage = getPageOgImage(page);
const canonical = getPageCanonical(page);

// Process HTML to fix image URLs and other issues
const processedHtml = processPageHtml(page);
---

<BaseLayout title={title} description={description} ogImage={ogImage} canonical={canonical}>
  <main>
    {
      processedHtml ? (
        <Fragment set:html={processedHtml} />
      ) : (
        <div>
          <h1>{title}</h1>
          <p>Page not found or content not available.</p>
          <p>URL: {path}</p>
        </div>
      )
    }
  </main>
</BaseLayout>
