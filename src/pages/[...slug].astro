---
import BaseLayout from '../layouts/BaseLayout.astro';
import {
  getAllPages,
  getPageTitle,
  getPageDescription,
  getPageOgImage,
  getPageCanonical,
} from '../utils/loadWebsiteData';
import { processPageHtml } from '../utils/processHtml';
import { isExcludedPath, siteConfig } from '../config/site.config';

// Only prerender paths that are actual pages
export const prerender = true;

export async function getStaticPaths() {
  const allPages = getAllPages();

  // Only generate paths for actual pages, not static assets
  const pagePaths = allPages
    .map(page => {
      // Convert URL to slug path string (remove protocol, query strings, trailing slashes)
      // e.g., "https://{baseDomain}/download?cpid=features" -> "{baseDomain}/download"
      let pagePath = page.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
      // Remove query strings
      pagePath = pagePath.split('?')[0].split('#')[0];

      return pagePath || siteConfig.baseDomain;
    })
    .filter(pagePath => {
      // Exclude paths using config-driven rules
      // This prevents the catch-all route from matching these paths
      return !isExcludedPath(`/${pagePath}`);
    });

  // Generate paths with domain prefix (for production)
  const pathsWithDomain = pagePaths.map(pagePath => {
    return {
      params: {
        slug: pagePath,
      },
    };
  });

  // Also generate paths without domain prefix (for local dev and simpler URLs)
  // Extract just the path part (e.g., "windscribe.com/features" -> "features")
  const baseDomainRegex = new RegExp(`^${siteConfig.baseDomain.replace(/\./g, '\\.')}\\/?`);
  const pathsWithoutDomain = pagePaths
    .map(pagePath => {
      const pathOnly = pagePath.replace(baseDomainRegex, '');
      // Only add if there's a path (not just the domain) and it's not empty
      return pathOnly && pathOnly !== pagePath ? pathOnly : null;
    })
    .filter((path): path is string => path !== null && path !== '')
    .map(pathOnly => {
      return {
        params: {
          slug: pathOnly,
        },
      };
    });

  // Combine both formats
  return [...pathsWithDomain, ...pathsWithoutDomain];
}

const { slug } = Astro.params;
// slug comes as an array for catch-all routes, join it back to a string
const path = slug ? (Array.isArray(slug) ? slug.join('/') : slug) : '';

// Early return for static assets and internal paths (using config)
// These should be handled by middleware, but double-check here as well
// This prevents any processing and route matching warnings
if (!path || isExcludedPath(`/${path}`)) {
  // Return 404 immediately - these paths shouldn't be handled by this route
  return new Response('Not Found', { status: 404, statusText: 'Not Found' });
}

// Find the page by matching the URL
const allPages = getAllPages();

// Normalize path - remove leading slash if present
let normalizedPath = path.startsWith('/') ? path.slice(1) : path;

let page = allPages.find(p => {
  const pagePath = p.url
    .replace(/^https?:\/\//, '')
    .replace(/\/$/, '')
    .split('?')[0]
    .split('#')[0];

  // Extract just the path part from pagePath (remove domain)
  const baseDomainRegex = new RegExp(`^${siteConfig.baseDomain.replace(/\./g, '\\.')}\\/?`);
  const pagePathOnly = pagePath.replace(baseDomainRegex, '') || pagePath;

  // Extract just the path part from normalizedPath (remove domain if present)
  const pathOnly = normalizedPath.replace(baseDomainRegex, '') || normalizedPath;

  // Exact match (with or without domain)
  if (pagePath === normalizedPath) return true;
  if (pagePathOnly === pathOnly && pathOnly) return true;

  // Match by path segment only (e.g., "features" matches "windscribe.com/features" or just "features")
  if (pathOnly && pagePathOnly === pathOnly) return true;
  if (pathOnly && pagePathOnly.endsWith(`/${pathOnly}`)) return true;
  if (pagePathOnly && pathOnly.endsWith(`/${pagePathOnly}`)) return true;

  // Match if page path includes the requested path (or vice versa)
  if (pagePathOnly.includes(pathOnly) || pathOnly.includes(pagePathOnly)) return true;
  if (pagePath.includes(normalizedPath) || normalizedPath.includes(pagePath)) return true;

  // Handle root domain
  if (
    (normalizedPath === siteConfig.baseDomain || normalizedPath === '' || pathOnly === '') &&
    (pagePath === siteConfig.baseDomain || pagePathOnly === '')
  )
    return true;
  return false;
});

// If not found, try more flexible matching
if (!page) {
  // Try matching by last segment
  const pathSegments = path.split('/');
  const lastSegment = pathSegments[pathSegments.length - 1];

  page = allPages.find(p => {
    const pagePath = p.url
      .replace(/^https?:\/\//, '')
      .replace(/\/$/, '')
      .split('?')[0]
      .split('#')[0];
    const pageSegments = pagePath.split('/');
    const pageLastSegment = pageSegments[pageSegments.length - 1];

    // Match by last segment
    if (lastSegment && pageLastSegment === lastSegment) return true;
    // Match if path is substring of page path
    if (pagePath.includes(path)) return true;
    return false;
  });
}

// Fallback to first page if still not found (guaranteed to exist since we have pages)
if (!page && allPages.length > 0) {
  page = allPages[0];
}

// Ensure we have a page (TypeScript safety)
if (!page) {
  return Astro.redirect('/');
}

const title = getPageTitle(page);
const description = getPageDescription(page);
const ogImage = getPageOgImage(page);
const canonical = getPageCanonical(page, siteConfig.baseUrl);

// Process HTML to fix image URLs and other issues
const processedHtml = processPageHtml(page);
---

<BaseLayout title={title} description={description} ogImage={ogImage} canonical={canonical}>
  <main>
    {
      processedHtml ? (
        <Fragment set:html={processedHtml} />
      ) : (
        <div>
          <h1>{title}</h1>
          <p>Page not found or content not available.</p>
          <p>URL: {path}</p>
        </div>
      )
    }
  </main>
</BaseLayout>
